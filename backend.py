# -*- coding: utf-8 -*-
"""
Created on Thu Aug 26 16:04:57 2021

@author: Surbhika Rastogi (213070056)
"""
#import libraries to access methods in further execution
import sys #for application execution
import cv2 #for image read, write and color transform operations
import os #for getting the current working directory
from PyQt5 import QtCore, QtGui, QtWidgets #for accessing GUI elements

from main_window_ui import Ui_MainWindow # import the GUI elements file generated by QT Designer
import numpy as np #for mathematical operations on image
    
class ImaqArt(Ui_MainWindow):

    def __init__(self, dialog):
        """
        This method runs at the instantiation of ImaqArt Class.
        It links the image operation functions to the widgets on GUI.
        """
        self.n = 0  #count for the saved images (each image is stored in memory with new identifier)
        self.image = 0  #initialise image variable
        Ui_MainWindow.__init__(self)    #instantiate the GUI dialog box
        self.setupUi(dialog)            #method in UI_MainWindow to instantiate widgets in the GUI
        
        """
        Below statements link the buttons and sliders on GUI with the method to be called when value is changed
        """
        self.Browse.clicked.connect(self.browse_files) #calls Browse Files method when browse button is clicked on GUI
        self.EqualisationBtn.clicked.connect(self.histogram_equilisation) #calls Histogram Equalisation method when EqualisationBtn button in clicked on GUI
        self.LogTransformBtn.clicked.connect(self.log_transformation) #calls Log Transformation method when LogTransformBtn button is clicked on GUI
        self.InvertBtn.clicked.connect(self.invert_image) #calls Invert Image method when InvertBtn button is clicked on GUI
        self.SaveImageBtn.clicked.connect(self.save_image) #calls Save Image method when SaveImageBtn button is clicked on GUI
        self.UndoBtn.clicked.connect(self.undo) #calls Undo method when UndoBtn button in clicked on GUI
        self.UndoAllBtn.clicked.connect(self.undo_all) #calls Undo All method when UndoAllBtn button in clicked on GUI
        # self.demo_list.itemClicked.connect(self.display_selected_item) #not used
        self.CameraBtn.clicked.connect(self.capture_image) #calls Capture Image method when CameraBtn button is clicked on GUI
        self.blur_slider.sliderReleased.connect(self.blur) #calls Blur method when blur_slider is released on GUI
        self.gamma_slider.sliderReleased.connect(self.gamma_correction) #calls Gamma Correction method when gamma_slider is released on GUI
        self.sharpen_slider.sliderReleased.connect(self.sharpen) #calls Sharpen method when sharpen_slider button is released on GUI


    def blur(self):
        
        """
        This method takes input an image, blur index input (which determines the size of filter) and outputs the blurred image
        """
        print('image blurring in process...')
        #self.ConsoleDisplay.setText("Image blurring in process...")

        img = self.image #image is stored for transformation
        bi = self.blur_slider.value()           #blur index

        #print(bi)
        
        size = len(np.shape(img)) #size of input image
        if size == 3:
            #if image is colored, then convert it to HSV format
            img_hsv = cv2.cvtColor(img, cv2.COLOR_RGB2HSV)
            #store V channel of HSV image for transformation
            img_temp = img_hsv[:,:,2]
    
        elif size == 2:
            #if image is black and white only, directly apply transformation to the image
            img_temp = img
        
        h,w = np.shape(img_temp) #rows and columns of image
        #print(h,w)
            
        img_temp_blur = np.zeros(shape=(h,w)) #create black empty image to store further transformations
        img_temp = img_temp.astype(int) #convert to int since uint8 default type overflows in case of transformations
        
        for i in range (bi, h-bi): #iterate over rows
            for j in range (bi, w-bi): #iterate over columns
                s = 0 #sum = 0
                for k in range(-bi,bi+1): #iterate over blur window
                    for l in range (-bi, bi+1): 
                        s = s + img_temp[i+k][j+l] #sum ovr pixels of a window
                img_temp_blur[i][j] = s//((2*(bi)+1)**2) #average of pixel neighbor window is stored in the current pixel
        
        img_temp_blur = img_temp_blur.astype(np.uint8) #reconvert to uint8 type for display

        
        if size == 3:
            #convert to RGB for display of image from HSV
            img_blur_hsv = np.dstack(tup = (img_hsv[:,:,0], img_hsv[:,:,1], img_temp_blur))
            img_blur = cv2.cvtColor(img_blur_hsv, cv2.COLOR_HSV2RGB)

            
        elif size == 2:
            #if image is black and white, directly send to display
            img_blur = img_temp_blur
        
        
       # img = cv2.blur(img,(val,val))  
        self.display_image(img_blur) #display the image
        print('image blurring in done')
        self.ConsoleDisplay.setText("Image blurring done") #update the console on GUI.

        
    def browse_files(self):
        """
        Browse for the selected file in current working directory and set the filname
        """
        
        filter = "Image files (*.jpg *.gif *.png)" #image formats allowed for the editor
        filename = QtWidgets.QFileDialog.getOpenFileName(None, 'Open file',os.getcwd() ,filter)     #browse images in current working directory    
        self.filename = filename[0] #load the filename selected

        # self.image_filename.setText(self.filename)
        self.display_file(self.filename) #set the filename for display
        img = cv2.imread(self.filename) #image read for display
        self.org_image = cv2.cvtColor(img, cv2.COLOR_BGR2RGB) #store original image copy for further use
        #print(np.shape(img))
        self.ConsoleDisplay.setText("Image loaded!") #update the console on GUI.
 
    
    def display_file(self, filename):
        """
        This method reads the image from given filename and displays it on the GUI Image display area by dynamic scaling of the pixels
        Parameters
        ----------
        filename : image filename to be loaded.

        Returns
        -------
        None.

        """
        img = cv2.imread(self.filename) #read image
        self.image = cv2.cvtColor(img, cv2.COLOR_BGR2RGB) #convert to RGB format
        pixmap = QtGui.QPixmap(filename) #convert to pixmap format for scaled display
        self.DisplayImage.setScaledContents(True) #scaling as per display
        self.DisplayImage.setPixmap(pixmap) #output the image
 
    
    def display_image(self, img):
        """
        This method display images stored in form of numpy array on the Image Display Area in GUI.

        Parameters
        ----------
        img : numpy array type.

        Returns
        -------
        None.

        """
        
        self.last_image = self.image #store the last image for further use
        self.image = img #image to be displayed
        h, w, ch = img.shape #dimensions of image
        bytesPerLine = ch * w 
        convertToQtFormat = QtGui.QImage(img.data, w, h, bytesPerLine, QtGui.QImage.Format_RGB888) #format to display
        p = convertToQtFormat.scaled(640, 480, QtCore.Qt.KeepAspectRatio) #scale the image as per aspect ratio of Display Element
        self.DisplayImage.setPixmap(QtGui.QPixmap.fromImage(p)) #display on GUI Display element
        


    def histogram_equilisation(self):
        """
        This methods performs the histogram equalisation algoritm and returns the transformed image for display
        """
        img = self.image #image to be transformed
        
        size = len(np.shape(img))#size of image
        if size == 3:
            #if image is colored, then convert it to HSV format
            img_hsv = cv2.cvtColor(img, cv2.COLOR_RGB2HSV)
            #store V channel of HSV image for transformation
            img_temp = img_hsv[:,:,2]
            
    
        elif size == 2:
            #if image is black and white only, directly apply transformation to the image
            img_temp = img
        
        #calls for eng=hance contrast method for image equalisation
        temp_eq = self.enhance_contrast(np.asarray(img_temp))
        temp_eq = temp_eq.astype(np.uint8) #convert back to default uint8 tyep for display
        
        if size == 3:
            #if image is colored, then convert it back to RGB format
            img_eq_hsv = np.dstack(tup = (img_hsv[:,:,0], img_hsv[:,:,1], temp_eq))
            img_eq = cv2.cvtColor(img_eq_hsv, cv2.COLOR_HSV2RGB)

            
        elif size == 2:
            #if image is black and white, directly send to display
            img_eq = temp_eq

        self.display_image(img_eq)
        #print('histogram equilisation done')
        self.ConsoleDisplay.setText("histogram equilisation done") #update the console on GUI.
        
    
    
    def gamma_correction(self):
        
        alpha = self.gamma_slider.value() /10      #assign alpha from front-end slider
     
        #print(alpha)
        
        img = self.image #store imgae for transformation
        
        size = len(np.shape(img)) #image shape
        if size == 3:
            #if image is colored, then convert it to HSV format
            img_hsv = cv2.cvtColor(img, cv2.COLOR_RGB2HSV)
            #store V channel of HSV image for transformation
            img_temp = img_hsv[:,:,2]
            
    
        elif size == 2:
            #if image is black and white only, directly apply transformation to the image
            img_temp = img
            
        img_temp_gamma = ((img_temp/255)**(alpha))*255 #gamma transformation
        img_temp_gamma = img_temp_gamma.astype(np.uint8) #convert back to default uint8 tyep for display
        
        if size == 3:
            #if image is colored, then convert it back to RGB format
            img_eq_hsv = np.dstack(tup = (img_hsv[:,:,0], img_hsv[:,:,1], img_temp_gamma))
            img_gamma = cv2.cvtColor(img_eq_hsv, cv2.COLOR_HSV2RGB)

            
        elif size == 2:
            #if image is black and white, directly send to display
            img_gamma = img_temp_gamma

        
        self.display_image(img_gamma)
       # print('gamma correction done') 
        self.ConsoleDisplay.setText("gamma correction done") #update the console on GUI.
        
    
    def log_transformation(self):
        
        #print('log transformation in process...')

        img = self.image
        size = len(np.shape(img))
        if size == 3:
            #if image is colored, then convert it to HSV format
            img_hsv = cv2.cvtColor(img, cv2.COLOR_RGB2HSV)
            #store V channel of HSV image for transformation
            img_temp = img_hsv[:,:,2]
    
        elif size == 2:
            #if image is black and white only, directly apply transformation to the image
            img_temp = img
        
        h,w = np.shape(img_temp)
        print(h,w)
            
        # img_temp_blur = np.zeros(shape=(h,w))
        img_temp = img_temp.astype(int)
        
        k = 255 / np.log(1 + np.max(img_temp)) #scaling factor calculation
        img_temp_log = k * (np.log(img_temp)) #log transformation of image
        img_temp_log = img_temp_log.astype(np.uint8) #convert back to default uint8 tyep for display

        if size == 3:
            #if image is colored, then convert it back to RGB format
            img_log_hsv = np.dstack(tup = (img_hsv[:,:,0], img_hsv[:,:,1], img_temp_log))
            img_log = cv2.cvtColor(img_log_hsv, cv2.COLOR_HSV2RGB)

            
        elif size == 2:
            #if image is black and white, directly send to display
            img_log = img_temp_log
        
        
       # img = cv2.blur(img,(val,val)) 
        self.display_image(img_log)
      
        #print('log transformation done')
        self.ConsoleDisplay.setText("Log transformation done") #update the console on GUI.
        
    
    def sharpen(self):
        #self.ConsoleDisplay.setText("Image sharpening in process...")
        val = self.sharpen_slider.value()/100
        
        img = self.image #store image for transformation
        
        size = len(np.shape(img)) #image shape
        if size == 3:
            #if image is colored, then convert it to HSV format
            img_hsv = cv2.cvtColor(img, cv2.COLOR_RGB2HSV)
            #store V channel of HSV image for transformation
            img_temp = img_hsv[:,:,2]
            print
    
        elif size == 2:
            #if image is black and white only, directly apply transformation to the image      
            img_temp = img
        
        h,w = np.shape(img_temp)
        img_temp = img_temp.astype(int)
        
        bi = 1      #high pass filter index
        
        img_hp = np.zeros(shape=(h,w))  #high pass filtered image to store in this
        
        #few columns and rows on the edges are not iterated due to the size of window but zero padding is done on it
        
        #HPF filter = [[-1,-1,-1],
        #               [-1,8,-1],
        #               [-1,-1,-1]]
        
        for i in range (bi, h-bi): #iterate over row
            for j in range (bi, w-bi): #iterate over columns
                s = 0 #sum=0
                for k in range(-bi,bi+1): #iterate over rows of window
                    for l in range (-bi, bi+1): #iterate over columns of window
                    
                        if k==0 and l==0: #center of window
                            s = s + 8*img_temp[i+k][j+l]
                        else:
                            s = s - img_temp[i+k][j+l] #elements other than center are subtracted
                            
                img_hp[i][j] = s/3 #average of neighboring pixels sum
        img_hp = img_hp * 255/max(img_hp.ravel())       
        img_hp = img_hp.astype(np.uint8) #convert back to default uint8 tyep for display
        
        img_temp_sharp = (val*(img_hp) + img_temp) #add edges extracted using HPF to original image 
        img_temp_sharp = (val*(img_hp) + img_temp) *255/max(img_temp_sharp.ravel())
        img_temp_sharp = img_temp_sharp.astype(np.uint8) #convert back to default uint8 tyep for display
        
        if size == 3:
            #if image is colored, then convert it back to RGB format
            img_sharp_hsv = np.dstack(tup = (img_hsv[:,:,0], img_hsv[:,:,1], img_temp_sharp))
            img_sharp = cv2.cvtColor(img_sharp_hsv, cv2.COLOR_HSV2RGB)

            
        elif size == 2:
            #if image is black and white, directly send to display
            img_sharp = img_temp_sharp

        self.display_image(img_sharp) #display image to GUI
        print(val)

        #('image sharpening done')
        self.ConsoleDisplay.setText("Image sharpening done") #update the console on GUI.

    def invert_image(self):
        """
        This method inverts the color of the given image
        """
        img = self.image # image to be transformed
        img_inv = 255-img #invert the image by subtracting from maximum value
        self.display_image(img_inv) #send for display
      
        #print('image inversion done')
        self.ConsoleDisplay.setText("Image inversion done") #update the console on GUI.
               

    def enhance_contrast(self,image_matrix, bins=256):
        #img_ary = np.asarray(image_matrix)
        image_flattened = image_matrix.flatten() #flatten the 2D array image
        image_hist = np.zeros(bins) #empty array for storing histogram
    
        # frequency count of each pixel
        for pix in image_matrix:
            image_hist[pix] += 1
    
       
        cum_sum = np.cumsum(image_hist) # cummulative sum
        norm = (cum_sum - cum_sum.min()) * 256
        
        n_ = cum_sum.max() - cum_sum.min() # normalization of the pixel values
        uniform_norm = norm / n_
        uniform_norm = uniform_norm.astype('int') #convert back to default uint8 tyep for display
    
        # flat histogram
        image_eq = uniform_norm[image_flattened]
        # reshaping the flattened matrix to its original shape
        image_eq = np.reshape(a=image_eq, newshape=image_matrix.shape)

        return image_eq
    
    def save_image(self):
        """
        This method saves the image to the current working directory with a unique name
        """
        img = cv2.cvtColor(self.image, cv2.COLOR_BGR2RGB) #convert to RGB format for display
        cv2.imwrite('ImaqArt'+str(self.n)+'.png',img) #filename to be saved
        self.n += 1 #filename identifier updated
        #print ('image saved: ' + str(self.n))
        self.ConsoleDisplay.setText("Image saved in current directory") #update the console on GUI.
    
    def undo_all(self):
        """
        This method revert all the changes that have been done on the image since the time it was loaded to the display
        """
        self.display_image(self.org_image) #display original image to display
        self.ConsoleDisplay.setText("All changes reverted") #update the console on GUI.
        
    def undo(self):
        """
        This method revert the last changes that have been done on the image display
        """
        self.display_image(self.last_image) #display last image on GUI
        self.ConsoleDisplay.setText("Last change reverted") #update the console on GUI.
        
    def capture_image(self):
        """
        This method is used to capture an image directly from the first camera of the device.
        The image captured is also displayed on the GUI
        """
        
        #self.ConsoleDisplay.setText("Camera inilisation...")
        camera = cv2.VideoCapture(0) #camera initialise
        #self.ConsoleDisplay.setText("Image being captured...")
        for i in range(10): #9 images read before saving the 10th one to warm up the camera
            return_value, image = camera.read()

        img = cv2.cvtColor(image, cv2.COLOR_BGR2RGB) #convert the image to RGB
        self.org_image = img #save the image for further use
        self.display_image(img) #display on GUI
        
        del(camera) #delete camera instance
        #print('image capture done')
        
        self.ConsoleDisplay.setText("Image captured") #update the console on GUI.
        
    
if __name__ == '__main__':
    """
    This is the main codeblock reponsible for instancing the main app.
    It further calls the GUI dialog box
    """
    app = QtCore.QCoreApplication.instance() #instantiate the GUI dialog box
    if app is None:
        app = QtWidgets.QApplication(sys.argv) #if not already started the QT instance, it starts the GUI dialo box
    main = QtWidgets.QMainWindow() #handle to the front end application
    prog = ImaqArt(main) #call the backend with frontend handle as argument
    main.show() #start the application
    sys.exit(app.exec_()) #exit the code execution when GUI application is closed